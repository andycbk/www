<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›·å°„é›•åˆ»æ¨¡æ“¬å·¥ä½œå° (Pro Dark)</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;
            --accent-color: #ff9800;
            --accent-hover: #ffb74d;
            --border-color: #333;
            --danger-color: #cf6679;
            --success-color: #4caf50;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Roboto, "Microsoft JhengHei", sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1, h2, h4 { margin: 0 0 15px 0; font-weight: 600; letter-spacing: 0.5px; }
        h1 { color: var(--accent-color); text-shadow: 0 0 10px rgba(255, 152, 0, 0.3); margin-bottom: 30px; }
        h4 { color: var(--text-muted); font-size: 0.9rem; text-transform: uppercase; margin-top: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        p { color: var(--text-muted); font-size: 0.9rem; margin-bottom: 15px; }

        .container {
            display: flex;
            width: 100%;
            max-width: 1000px;
            gap: 30px;
            align-items: flex-start;
        }

        .sidebar {
            width: 320px;
            background-color: var(--panel-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--panel-bg);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            border: 1px solid var(--border-color);
        }

        .control-group {
            background: #2c2c2c;
            padding: 5px;
            border-radius: 8px;
            display: flex;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .control-group label, .control-group button {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 0.9rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .control-group input[type="radio"] { display: none; }
        
        .control-group input[type="radio"]:checked + span,
        .control-group button.active {
            background-color: var(--accent-color);
            color: #000;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4);
        }
        
        .control-group label:hover, .control-group button:hover:not(.active) {
            color: var(--text-main);
            background-color: rgba(255,255,255,0.05);
        }

        input[type="text"], input[type="file"] {
            width: 100%;
            padding: 10px;
            background-color: #2c2c2c;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-main);
            font-size: 0.9rem;
            margin-bottom: 10px;
            outline: none;
        }
        input[type="text"]:focus { border-color: var(--accent-color); }

        .range-group {
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        input[type=range] {
            -webkit-appearance: none;
            width: 60%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #444;
            border-radius: 2px;
        }
        input[type=range]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.3);
        }

        canvas {
            width: 100%;
            max-width: 600px;
            height: auto;
            border: 2px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            background-color: #2a2a2a;
            transition: transform 0.2s;
        }
        canvas.dragging { cursor: grabbing; transform: scale(1.01); box-shadow: 0 0 15px var(--accent-color); }

        .text-item {
            background-color: #2c2c2c;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            border-left: 4px solid transparent;
            transition: 0.2s;
            font-size: 0.9rem;
        }
        .text-item:hover { background-color: #333; }
        .text-item.selected {
            background-color: #333;
            border-left-color: var(--accent-color);
            color: var(--accent-color);
        }

        .action-btn {
            width: 100%;
            padding: 12px;
            background-color: var(--success-color);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .action-btn:hover { background-color: #43a047; box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); }
        
        .secondary-btn {
            background-color: #333;
            color: var(--text-main);
            border: 1px solid var(--border-color);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            transition: 0.2s;
        }
        .secondary-btn:hover { background-color: #444; }
        
        .danger-btn {
            background-color: transparent;
            color: var(--danger-color);
            border: 1px solid var(--danger-color);
            margin-top: 10px;
        }
        .danger-btn:hover { background-color: rgba(207, 102, 121, 0.1); }
        
        @media (max-width: 850px) {
            .container { flex-direction: column; }
            .sidebar { width: 100%; }
        }
    </style>
</head>
<body>
    <h1>âš¡ é›·å°„é›•åˆ»æ¨¡æ“¬å·¥ä½œå°</h1>
    
    <div class="container">
        <div class="sidebar">
            <h2 style="font-size: 1.2rem; margin-bottom: 20px; border-left: 4px solid var(--accent-color); padding-left: 10px;">è¨­è¨ˆé¢æ¿</h2>
            
            <div class="control-group">
                <label>
                    <input type="radio" name="orientation" value="landscape" checked onchange="setOrientation('landscape')">
                    <span>ğŸ“ æ©«å‘ç‰ˆå‹</span>
                </label>
                <label>
                    <input type="radio" name="orientation" value="portrait" onchange="setOrientation('portrait')">
                    <span>ğŸ“ ç›´å‘ç‰ˆå‹</span>
                </label>
            </div>

            <div class="control-group">
                <button id="btn-img-mode" class="active" onclick="setMode('image')">ğŸ“¸ åœ–ç‰‡æ¨¡å¼</button>
                <button id="btn-text-mode" onclick="setMode('text')">âœï¸ æ–‡å­—æ¨¡å¼</button>
            </div>

            <div id="img-controls">
                <p>ä¸Šå‚³åœ–ç‰‡ä¸¦èª¿æ•´åƒæ•¸ä»¥ç²å¾—æœ€ä½³é›•åˆ»æ•ˆæœ</p>
                <input type="file" id="upload" accept="image/*">
                
                <h4>å½±åƒå‰ç½®è™•ç†</h4>
                <div class="range-group">
                    <label for="brightness">äº®åº¦</label>
                    <input type="range" id="brightness" min="-100" max="100" value="0" oninput="processCurrentMode()">
                </div>
                <div class="range-group">
                    <label for="contrast">å°æ¯”åº¦</label>
                    <input type="range" id="contrast" min="-100" max="100" value="0" oninput="processCurrentMode()">
                </div>
                <div class="range-group">
                    <label for="sharpening">éŠ³åˆ©åº¦</label>
                    <input type="range" id="sharpening" min="0" max="3" step="0.1" value="0" oninput="processCurrentMode()">
                </div>
                <div class="range-group">
                    <label for="vignette">é‚Šç·£æ·¡åŒ–</label>
                    <input type="range" id="vignette" min="0" max="1" step="0.05" value="0" oninput="processCurrentMode()">
                </div>
                
                <h4>é›·å°„é»é™£åŒ–è¨­å®š</h4>
                <div class="range-group">
                    <label for="dither-threshold">é»‘ç™½é–¥å€¼</label>
                    <input type="range" id="dither-threshold" min="0" max="255" value="128" oninput="processCurrentMode()">
                </div>
                <div class="range-group">
                    <label for="burn-intensity">ç‡’ç¼æ·±åº¦</label>
                    <input type="range" id="burn-intensity" min="100" max="255" value="220" oninput="processCurrentMode()">
                </div>
            </div>

            <div id="text-controls" style="display: none;">
                <button class="secondary-btn" onclick="addTextItem()" style="color: var(--accent-color); border-color: var(--accent-color);">+ æ–°å¢æ–‡å­—ç‰©ä»¶</button>
                
                <h4>æ–‡å­—åœ–å±¤</h4>
                <div id="text-list"></div>

                <div id="active-text-controls" style="background: #252525; padding: 15px; margin-top: 15px; border-radius: 8px; display: none; border: 1px solid #444;">
                    <h4 style="margin-top: 0; border-bottom: none; color: var(--text-main);">ç·¨è¼¯å…§å®¹</h4>
                    <input type="text" id="edit-content" placeholder="è¼¸å…¥æ–‡å­—å…§å®¹" oninput="updateActiveText()">
                    
                    <div class="range-group" style="margin-top: 10px;">
                        <label>å­—é«”å¤§å°</label>
                        <input type="range" id="edit-font-size" min="10" max="150" value="30" oninput="updateActiveText()">
                    </div>
                    
                    <button class="secondary-btn danger-btn" onclick="deleteActiveText()">åˆªé™¤æ­¤åœ–å±¤</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <canvas id="previewCanvas" width="600" height="400" title="é»æ“Šä¸¦æ‹–æ›³æ–‡å­—ä¾†ç§»å‹•ä½ç½®"></canvas>
            <button class="action-btn" onclick="downloadImage()">ğŸ’¾ ä¸‹è¼‰æˆå“ (PNG)</button>
            <p style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">æç¤ºï¼šèª¿æ•´ã€Œé‚Šç·£æ·¡åŒ–ã€å¯ä»¥è®“ç…§ç‰‡é‚Šç·£æŸ”å’Œæ¶ˆå¤±ï¼Œé¿å…å‡ºç¾æ–¹æ¡†ã€‚</p>
        </div>
    </div>

<script>
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');
    const uploadInput = document.getElementById('upload');
    const textList = document.getElementById('text-list');
    const editContent = document.getElementById('edit-content');
    const editFontSize = document.getElementById('edit-font-size');
    const activeTextControls = document.getElementById('active-text-controls');
    
    let currentMode = 'image';
    let currentOrientation = 'landscape';
    let originalImage = null;
    let textItems = [];
    let selectedTextIndex = -1;
    let isDragging = false;
    let dragItemIndex = -1;
    let dragOffsetX, dragOffsetY;

    // åˆå§‹åŒ–
    textItems.push({ 
        content: "DESIGN LAB", 
        fontSize: 50, 
        x: canvas.width / 2, 
        y: canvas.height / 2 
    });
    updateTextListUI();
    processCurrentMode();

    function setOrientation(orientation) {
        currentOrientation = orientation;
        if (orientation === 'landscape') {
            canvas.width = 600;
            canvas.height = 400;
        } else {
            canvas.width = 400;
            canvas.height = 600;
        }
        
        textItems.forEach(item => {
            item.x = canvas.width / 2;
            item.y = canvas.height / 2;
        });

        processCurrentMode();
    }

    function setMode(mode) {
        currentMode = mode;
        document.getElementById('btn-img-mode').className = 'mode-btn ' + (mode === 'image' ? 'active' : '');
        document.getElementById('btn-text-mode').className = 'mode-btn ' + (mode === 'text' ? 'active' : '');
        document.getElementById('img-controls').style.display = mode === 'image' ? 'block' : 'none';
        document.getElementById('text-controls').style.display = mode === 'text' ? 'block' : 'none';
        selectTextItem(-1);
        processCurrentMode();
    }

    uploadInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                originalImage = img;
                processCurrentMode();
            }
            img.src = event.target.result;
        }
        reader.readAsDataURL(file);
    });

    function processCurrentMode() {
        drawWoodBackground();
        
        if (currentMode === 'image' && originalImage) {
            renderDitheredImage();
        } else if (currentMode === 'text') {
            renderText();
        }
    }

    function addTextItem() {
        const defaultText = {
            content: "æ–°æ–‡å­—",
            fontSize: 30,
            x: canvas.width / 2,
            y: canvas.height / 2 + (textItems.length * 5),
        };
        textItems.push(defaultText);
        updateTextListUI();
        selectTextItem(textItems.length - 1);
        processCurrentMode();
    }

    function updateTextListUI() {
        textList.innerHTML = '';
        textItems.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'text-item' + (index === selectedTextIndex ? ' selected' : '');
            div.textContent = `[${item.fontSize}px] ${item.content.substring(0, 15)}${item.content.length > 15 ? '...' : ''}`;
            div.onclick = () => selectTextItem(index);
            textList.appendChild(div);
        });
    }

    function selectTextItem(index) {
        selectedTextIndex = index;
        updateTextListUI();

        if (index !== -1) {
            const item = textItems[index];
            editContent.value = item.content;
            editFontSize.value = item.fontSize;
            activeTextControls.style.display = 'block';
        } else {
            activeTextControls.style.display = 'none';
        }
    }

    function updateActiveText() {
        if (selectedTextIndex === -1) return;

        const item = textItems[selectedTextIndex];
        item.content = editContent.value;
        item.fontSize = parseInt(editFontSize.value);
        updateTextListUI();
        processCurrentMode();
    }
    
    function deleteActiveText() {
        if (selectedTextIndex === -1) return;
        
        if (confirm(`ç¢ºå®šè¦åˆªé™¤æ–‡å­—: "${textItems[selectedTextIndex].content.substring(0, 10)}..." å—ï¼Ÿ`)) {
            textItems.splice(selectedTextIndex, 1);
            selectTextItem(-1);
            processCurrentMode();
        }
    }

    function drawWoodBackground() {
        const w = canvas.width;
        const h = canvas.height;
        
        ctx.fillStyle = '#DEB887';
        ctx.fillRect(0, 0, w, h);

        const imageData = ctx.getImageData(0, 0, w, h);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            const noise = (Math.random() - 0.5) * 25; 
            data[i] = Math.min(255, Math.max(0, data[i] + noise));
            data[i+1] = Math.min(255, Math.max(0, data[i+1] + noise));
            data[i+2] = Math.min(255, Math.max(0, data[i+2] + noise));
        }
        ctx.putImageData(imageData, 0, 0);
        
        ctx.globalAlpha = 0.15;
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        const numLines = (currentOrientation === 'portrait') ? 25 : 20;
        
        for(let i=0; i<numLines; i++){
            if (currentOrientation === 'landscape') {
                 const y = Math.random() * h;
                 ctx.moveTo(0, y);
                 ctx.bezierCurveTo(w/3, y + Math.random()*40, w/3*2, y - Math.random()*40, w, y + Math.random()*30);
            } else {
                 const x = Math.random() * w;
                 ctx.moveTo(x, 0);
                 ctx.bezierCurveTo(x + Math.random()*40, h/3, x - Math.random()*40, h/3*2, x + Math.random()*30, h);
            }
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        if (currentOrientation === 'portrait') {
             drawHole(w / 2, 30);
        }
    }

    function drawHole(x, y) {
        ctx.fillStyle = '#3e2312';
        ctx.beginPath();
        const holeW = 60;
        const holeH = 15;
        const r = holeH / 2;
        ctx.moveTo(x - holeW/2 + r, y - holeH/2);
        ctx.lineTo(x + holeW/2 - r, y - holeH/2);
        ctx.quadraticCurveTo(x + holeW/2, y - holeH/2, x + holeW/2, y);
        ctx.lineTo(x + holeW/2, y);
        ctx.quadraticCurveTo(x + holeW/2, y + holeH/2, x + holeW/2 - r, y + holeH/2);
        ctx.lineTo(x - holeW/2 + r, y + holeH/2);
        ctx.quadraticCurveTo(x - holeW/2, y + holeH/2, x - holeW/2, y);
        ctx.lineTo(x - holeW/2, y);
        ctx.quadraticCurveTo(x - holeW/2, y - holeH/2, x - holeW/2 + r, y - holeH/2);
        ctx.fill();
        
        ctx.strokeStyle = 'rgba(60, 30, 10, 0.6)';
        ctx.lineWidth = 3;
        ctx.stroke();
    }

    function applySharpen(data, width, height, level) {
        if (level === 0) return data;
        const kernel = [ 0, -level, 0, -level, 1 + 4 * level, -level, 0, -level, 0 ];
        const newArray = new Uint8ClampedArray(data.length);
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                for (let c = 0; c < 3; c++) { 
                    let sum = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            sum += data[((y + ky) * width + (x + kx)) * 4 + c] * kernel[(ky + 1) * 3 + (kx + 1)];
                        }
                    }
                    newArray[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));
                }
                newArray[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
            }
        }
        for (let i = 0; i < data.length; i += 4) {
            if (newArray[i] === 0 && newArray[i+1] === 0 && newArray[i+2] === 0) {
                 newArray[i] = data[i]; newArray[i+1] = data[i+1]; newArray[i+2] = data[i+2]; newArray[i+3] = data[i+3];
            }
        }
        return newArray;
    }

    function renderDitheredImage() {
        if (!originalImage) return;

        const w = canvas.width;
        const h = canvas.height;
        const padding = 40;
        const availableW = w - padding;
        const availableH = h - padding;

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        const scale = Math.min(availableW / originalImage.width, availableH / originalImage.height);
        const imgW = Math.floor(originalImage.width * scale);
        const imgH = Math.floor(originalImage.height * scale);
        const offsetX = Math.floor((w - imgW) / 2);
        let offsetY = Math.floor((h - imgH) / 2);
        if (currentOrientation === 'portrait') offsetY += 20;

        tempCanvas.width = imgW;
        tempCanvas.height = imgH;
        tempCtx.drawImage(originalImage, 0, 0, imgW, imgH);
        
        let imageData = tempCtx.getImageData(0, 0, imgW, imgH);
        let data = imageData.data;
        
        const brightnessValue = parseInt(document.getElementById('brightness').value);
        const contrastValue = parseInt(document.getElementById('contrast').value);
        const sharpenLevel = parseFloat(document.getElementById('sharpening').value);
        const vignetteLevel = parseFloat(document.getElementById('vignette').value);
        const ditherThreshold = parseInt(document.getElementById('dither-threshold').value);
        const burnIntensity = parseInt(document.getElementById('burn-intensity').value);

        data = applySharpen(data, imgW, imgH, sharpenLevel);

        const contrastFactor = (259 * (contrastValue + 255)) / (255 * (259 - contrastValue));
        const pivot = 128;

        let gray = new Float32Array(imgW * imgH);
        
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i+1], b = data[i+2];
            r += brightnessValue; g += brightnessValue; b += brightnessValue;
            let grayVal = r * 0.3 + g * 0.59 + b * 0.11;
            let adjustedGray = contrastFactor * (grayVal - pivot) + pivot;
            
            if (vignetteLevel > 0) {
                const pixelIndex = i / 4;
                const x = pixelIndex % imgW;
                const y = Math.floor(pixelIndex / imgW);
                const center_x = imgW / 2;
                const center_y = imgH / 2;
                const dist_sq = (x - center_x) ** 2 + (y - center_y) ** 2;
                const max_dist_sq = (center_x) ** 2 + (center_y) ** 2;
                const normalized_dist = Math.sqrt(dist_sq / max_dist_sq);
                const fadeFactor = normalized_dist * vignetteLevel;
                adjustedGray = adjustedGray + (255 - adjustedGray) * fadeFactor;
            }
            gray[i / 4] = Math.max(0, Math.min(255, adjustedGray));
        }

        for (let y = 0; y < imgH; y++) {
            for (let x = 0; x < imgW; x++) {
                let idx = y * imgW + x;
                let oldPixel = gray[idx];
                let newPixel = oldPixel < ditherThreshold ? 0 : 255; 
                gray[idx] = newPixel;
                let quantError = oldPixel - newPixel;
                if (x + 1 < imgW) gray[idx + 1] += quantError * 7 / 16;
                if (x - 1 >= 0 && y + 1 < imgH) gray[idx + imgW - 1] += quantError * 3 / 16;
                if (y + 1 < imgH) gray[idx + imgW] += quantError * 5 / 16;
                if (x + 1 < imgW && y + 1 < imgH) gray[idx + imgW + 1] += quantError * 1 / 16;
            }
        }

        const resultData = ctx.createImageData(imgW, imgH);
        const rData = resultData.data;
        for (let i = 0; i < gray.length; i++) {
            const pixelVal = gray[i];
            if (pixelVal === 0) {
                rData[i*4] = 60; rData[i*4+1] = 30; rData[i*4+2] = 10; rData[i*4+3] = burnIntensity; 
            } else {
                rData[i*4+3] = 0; 
            }
        }
        tempCtx.putImageData(resultData, 0, 0);
        ctx.drawImage(tempCanvas, offsetX, offsetY);
    }

    function getTextBounds(item) {
        ctx.font = `bold ${item.fontSize}px "Microsoft JhengHei", sans-serif`;
        const lines = item.content.split(/[\n/]+/);
        const lineHeight = item.fontSize * 1.2;
        let maxWidth = 0;
        lines.forEach(line => {
            const metrics = ctx.measureText(line.trim());
            maxWidth = Math.max(maxWidth, metrics.width);
        });
        const totalHeight = lines.length * lineHeight;
        return {
            x: item.x - maxWidth / 2,
            y: item.y - totalHeight / 2,
            width: maxWidth,
            height: totalHeight
        };
    }

    function renderText() {
        textItems.forEach((item, index) => {
            ctx.font = `bold ${item.fontSize}px "Microsoft JhengHei", sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "rgba(60, 30, 10, 0.9)";
            ctx.shadowColor = "rgba(40, 20, 5, 0.6)";
            ctx.shadowBlur = 4; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;

            const lines = item.content.split(/[\n/]+/);
            const lineHeight = item.fontSize * 1.2;
            const totalHeight = lines.length * lineHeight;
            let startY = item.y - (totalHeight / 2) + (lineHeight / 2);

            lines.forEach((line, lineIndex) => {
                 ctx.fillText(line.trim(), item.x, startY + (lineIndex * lineHeight));
            });

            ctx.shadowColor = "transparent"; ctx.shadowBlur = 0; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
            
            if (index === selectedTextIndex) {
                 const bounds = getTextBounds(item);
                 ctx.strokeStyle = 'rgba(255, 152, 0, 0.8)';
                 ctx.lineWidth = 2;
                 ctx.setLineDash([5, 5]);
                 ctx.strokeRect(bounds.x - 8, bounds.y - 8, bounds.width + 16, bounds.height + 16);
                 ctx.setLineDash([]);
            }
        });
    }

    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    function hitTest(x, y) {
        for (let i = textItems.length - 1; i >= 0; i--) {
            const bounds = getTextBounds(textItems[i]);
            if (x > bounds.x - 8 && x < bounds.x + bounds.width + 16 && 
                y > bounds.y - 8 && y < bounds.y + bounds.height + 16) {
                return i;
            }
        }
        return -1;
    }

    canvas.addEventListener('mousedown', function(e) {
        if (currentMode !== 'text') return;

        const pos = getMousePos(e);
        const hitIndex = hitTest(pos.x, pos.y);

        if (hitIndex !== -1) {
            isDragging = true;
            dragItemIndex = hitIndex;
            selectTextItem(hitIndex);
            dragOffsetX = pos.x - textItems[hitIndex].x;
            dragOffsetY = pos.y - textItems[hitIndex].y;
            canvas.classList.add('dragging');
        } else {
            selectTextItem(-1);
        }
    });

    canvas.addEventListener('mousemove', function(e) {
        if (currentMode !== 'text') return;
        
        const pos = getMousePos(e);
        if (hitTest(pos.x, pos.y) !== -1) {
             canvas.style.cursor = 'grab';
        } else {
             canvas.style.cursor = 'default';
        }
        
        if (!isDragging) return;

        const newPos = getMousePos(e);
        const item = textItems[dragItemIndex];
        item.x = newPos.x - dragOffsetX;
        item.y = newPos.y - dragOffsetY;
        item.x = Math.max(0, Math.min(canvas.width, item.x));
        item.y = Math.max(0, Math.min(canvas.height, item.y));
        processCurrentMode();
    });

    canvas.addEventListener('mouseup', function() {
        if (currentMode !== 'text') return;
        isDragging = false;
        dragItemIndex = -1;
        canvas.classList.remove('dragging');
        canvas.style.cursor = 'default';
    });
    
    document.addEventListener('mouseup', function() {
        if (isDragging) {
             isDragging = false;
             dragItemIndex = -1;
             canvas.classList.remove('dragging');
             canvas.style.cursor = 'default';
        }
    });

    function downloadImage() {
        const originalSelected = selectedTextIndex;
        selectTextItem(-1);
        processCurrentMode();
        
        const link = document.createElement('a');
        link.download = currentOrientation === 'portrait' ? 'laser_badge_portrait.png' : 'laser_wood_landscape.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        selectTextItem(originalSelected);
        processCurrentMode();
    }
</script>
</body>
</html>
