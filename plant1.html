<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Â§™Á©∫Â∞ÑÊìäÔºöÁÅ´ÂäõÂÖ®Èñã</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #000; overflow: hidden; touch-action: none; font-family: 'Monaco', 'Menlo', 'monospace'; color: #E0E0E0; }
        #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #game-canvas { display: block; width: 100%; height: 100%; background-color: #0c0c1a; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #info-panel { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; font-size: 16px; text-shadow: 0 0 5px #fff; flex-wrap: wrap; gap: 10px; }
        #score, #high-score, #lives { flex: 1; min-width: 120px; }
        #score { text-align: left; }
        #high-score { text-align: center; }
        #lives { text-align: right; }
        
        /* ‰∏ªÊ≠¶Âô®UI */
        #main-weapon-ui {
            position: absolute;
            top: 50px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #main-weapon-icon { font-size: 24px; }
        #main-weapon-progress-bar {
            width: 100px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
        }
        #main-weapon-progress {
            width: 0%;
            height: 100%;
            background-color: #3498db;
            transition: width 0.3s ease;
        }

        /* ÂâØÊ≠¶Âô®UI */
        #sub-weapon-panel {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .sub-weapon-slot {
            width: 55px;
            height: 55px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            background-color: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        .sub-weapon-timer-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; background-color: rgba(0, 0, 0, 0.75); padding: 30px; border-radius: 15px; border: 2px solid #444; max-width: 90%; line-height: 1.6; }
        .message-title { font-size: 28px; margin-bottom: 15px; color: #61dafb; }
        .message-text { font-size: 16px; margin-bottom: 20px; }
        .button-group { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
        .ui-btn { padding: 15px 30px; font-size: 18px; font-family: inherit; color: white; border: 2px solid #fff; border-radius: 10px; cursor: pointer; pointer-events: auto; text-transform: uppercase; transition: all 0.2s ease; margin-top: 10px; background: transparent; text-shadow: 0 0 8px #fff; }
        .ui-btn:hover { background-color: #fff; color: #000; box-shadow: 0 0 20px #fff; }
        .ui-btn:active { transform: scale(0.95); }
        .btn-primary { background-color: #3498db; border-color: #3498db; }
        .btn-success { background-color: #4CAF50; border-color: #4CAF50; }
        .btn-danger { background-color: #e74c3c; border-color: #e74c3c; }

        #unlock-toast { position: absolute; top: 25%; left: 50%; transform: translateX(-50%); padding: 10px 20px; background-color: rgba(46, 204, 113, 0.8); border-radius: 10px; font-size: 20px; opacity: 0; transition: opacity 0.5s ease; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-overlay">
            <div id="info-panel" style="display: none;">
                <div id="score">ÂàÜÊï∏: 0</div>
                <div id="high-score">ÊúÄÈ´òÂàÜ: 0</div>
                <div id="lives">ÁîüÂëΩ: 10</div>
                <div id="main-weapon-ui">
                    <div id="main-weapon-icon"></div>
                    <div id="main-weapon-progress-bar"><div id="main-weapon-progress"></div></div>
                </div>
            </div>
            <div id="sub-weapon-panel" style="display: none;"></div>
            <div id="unlock-toast"></div>
            <div id="message-box">
                <div id="message-title">ÊéßÂà∂ÊñπÂºè</div>
                <div id="message-text">Ë´ãÈÅ∏Êìá‰Ω†ÁöÑÈÅäÊà≤ÊéßÂà∂ÊñπÂºè</div>
                <div class="button-group">
                    <button id="gyro-btn" class="ui-btn btn-primary">ÈôÄËû∫ÂÑÄ</button>
                    <button id="touch-btn" class="ui-btn btn-primary">Ëß∏ÊéßËû¢Âπï</button>
                </div>
                <div id="permission-request" style="display: none; margin-top: 15px;"><button id="permission-btn" class="ui-btn btn-success">ÂÖÅË®±ÈôÄËû∫ÂÑÄÊ¨äÈôê</button></div>
                <div id="instructions" style="display: none; margin-top: 15px;"><div id="instructions-text" class="message-text"></div><button id="start-btn" class="ui-btn btn-success">ÈñãÂßãÈÅäÊà≤</button></div>
                <div id="game-over-box" style="display: none;"><button id="restart-btn" class="ui-btn btn-danger">ÈáçÊñ∞ÈñãÂßã</button></div>
            </div>
        </div>
    </div>

    <script>
        // --- ÈÅäÊà≤Ë®≠ÂÆö ---
        const GAME_SETTINGS = {
            PLAYER_MAX_SPEED: 8, LIVES_START_COUNT: 10, GYRO_SENSITIVITY: 0.7,
            INVINCIBILITY_DURATION: 120, POWERUP_DROP_CHANCE: 0.3, POWERUP_LIFESPAN: 900, POWERUP_SIZE: 15,
            MAIN_WEAPON_XP_TO_LEVEL: 3, SUB_WEAPON_DURATION: 600, // 10Áßí
        };
        const POWERUP_TYPES = { MAIN_UPGRADE: 'main_upgrade', LASER: 'laser', SIDE_GUNS: 'sideGuns', MISSILES: 'missiles', HEAL: 'heal', SHIELD: 'shield' };

        // --- DOM ÂÖÉÁ¥† ---
        const canvas = document.getElementById('game-canvas'); const ctx = canvas.getContext('2d');
        const infoPanel = document.getElementById('info-panel'); const scoreElement = document.getElementById('score'); const highScoreElement = document.getElementById('high-score');
        const livesElement = document.getElementById('lives'); const mainWeaponUI = document.getElementById('main-weapon-ui');
        const mainWeaponIcon = document.getElementById('main-weapon-icon'); const mainWeaponProgress = document.getElementById('main-weapon-progress');
        const subWeaponPanel = document.getElementById('sub-weapon-panel'); const unlockToast = document.getElementById('unlock-toast');
        const messageBox = document.getElementById('message-box'); const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text'); const gyroBtn = document.getElementById('gyro-btn');
        const touchBtn = document.getElementById('touch-btn'); const permissionRequest = document.getElementById('permission-request');
        const permissionBtn = document.getElementById('permission-btn'); const instructions = document.getElementById('instructions');
        const instructionsText = document.getElementById('instructions-text'); const startBtn = document.getElementById('start-btn');
        const gameOverBox = document.getElementById('game-over-box'); const restartBtn = document.getElementById('restart-btn');
        
        // --- ÈÅäÊà≤ÁãÄÊÖã ---
        const gameState = {
            started: false, score: 0, highScore: 0, lives: GAME_SETTINGS.LIVES_START_COUNT,
            gameOver: false, animationId: null, lastEnemySpawnTime: 0, lastBulletTime: 0,
            controlScheme: null, touchDirection: null,
            enemySpawnInterval: 1000, maxEnemySpeed: 2.0, hasShield: false,
            mainWeaponLevel: 1, mainWeaponXP: 0,
            subWeapon: { type: null, timer: 0 }
        };

        // --- ÈÅäÊà≤Áâ©‰ª∂ ---
        const player = { x: 0, y: 0, width: 50, height: 60, isInvincible: false, invincibleTimer: 0 };
        const bullets = [], enemies = [], particles = [], stars = [], powerUps = [];

        // --- ÂàùÂßãÂåñ & Ë¶ñÁ™óÂ§ßÂ∞è ---
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; player.x = canvas.width / 2; player.y = canvas.height - 100; initStars(); }
        window.addEventListener('resize', resizeCanvas);
        function initStars() { stars.length = 0; for (let i = 0; i < 150; i++) { stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.5, speed: Math.random() * 0.5 + 0.2 }); } }
        
        // --- ÊéßÂà∂ÊñπÂºèÈÅ∏Êìá ---
        function selectControlScheme(scheme) {
            gameState.controlScheme = scheme; messageText.style.display = 'none'; document.querySelector('.button-group').style.display = 'none';
            if (scheme === 'gyro') { if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') { permissionRequest.style.display = 'block'; } else if (window.DeviceOrientationEvent) { window.addEventListener('deviceorientation', handleOrientation); showInstructions(); } else { alert('ÊÇ®ÁöÑË®≠ÂÇô‰∏çÊîØÊåÅÈôÄËû∫ÂÑÄÔºåË´ãÂà∑Êñ∞‰∏¶ÈÅ∏ÊìáËß∏Êéß„ÄÇ'); }
            } else { showInstructions(); }
        }
        permissionBtn.addEventListener('click', () => { DeviceOrientationEvent.requestPermission().then(response => { if (response === 'granted') { window.addEventListener('deviceorientation', handleOrientation); permissionRequest.style.display = 'none'; showInstructions(); } else { alert('ÊÇ®ÊãíÁµï‰∫ÜÊ¨äÈôêÔºåË´ãÂà∑Êñ∞‰∏¶ÈÅ∏ÊìáËß∏Êéß„ÄÇ'); } }); });
        function showInstructions() { instructionsText.innerHTML = gameState.controlScheme === 'gyro' ? "- ÂÇæÊñúË®≠ÂÇôÊéßÂà∂È£õËàπÁßªÂãï<br>- Ê≠¶Âô®ÊúÉËá™ÂãïÁôºÂ∞Ñ" : "- Êåâ‰ΩèËû¢ÂπïÂ∑¶/Âè≥ÂçäÈÇäÁßªÂãï<br>- Ê≠¶Âô®ÊúÉËá™ÂãïÁôºÂ∞Ñ"; instructions.style.display = 'block'; }
        function handleOrientation(event) { if (event.gamma !== null) { const tilt = Math.max(-45, Math.min(45, event.gamma)); player.x += tilt * GAME_SETTINGS.GYRO_SENSITIVITY; } }

        // --- ÈÅäÊà≤ÊµÅÁ®ã ---
        function startGame() {
            Object.assign(gameState, {
                started: true, score: 0, lives: GAME_SETTINGS.LIVES_START_COUNT, gameOver: false, hasShield: false,
                mainWeaponLevel: 1, mainWeaponXP: 0, subWeapon: { type: null, timer: 0 },
                enemySpawnInterval: 1000, maxEnemySpeed: 2.0
            });
            loadHighScore(); updateAllUI();
            
            messageBox.style.display = 'none'; infoPanel.style.display = 'flex'; mainWeaponUI.style.display = 'flex'; subWeaponPanel.style.display = 'flex';
            [bullets, enemies, particles, powerUps].forEach(arr => arr.length = 0);
            player.x = canvas.width / 2; player.y = canvas.height - 100;
            if (!gameState.animationId) gameLoop();
        }
        function doGameOver() { gameState.gameOver = true; cancelAnimationFrame(gameState.animationId); gameState.animationId = null; saveHighScore(); messageTitle.textContent = "ÈÅäÊà≤ÁµêÊùü"; messageText.textContent = `ÊúÄÁµÇÂàÜÊï∏: ${gameState.score}`; gameOverBox.style.display = 'block'; instructions.style.display = 'none'; messageBox.style.display = 'block'; mainWeaponUI.style.display = 'none'; subWeaponPanel.style.display = 'none'; }
        function loadHighScore() { gameState.highScore = localStorage.getItem('comboShooterHighScore') || 0; }
        function saveHighScore() { if (gameState.score > gameState.highScore) { gameState.highScore = gameState.score; localStorage.setItem('comboShooterHighScore', gameState.highScore); } }

        // --- Áπ™Âúñ & Êõ¥Êñ∞ ---
        function drawPlayer() {
            if (player.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) return;
            ctx.fillStyle = '#00BFFF'; ctx.beginPath(); ctx.moveTo(player.x, player.y - player.height / 3); ctx.lineTo(player.x + player.width / 2, player.y + player.height / 3); ctx.lineTo(player.x - player.width / 2, player.y + player.height / 3); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#FFF'; ctx.fillRect(player.x - 5, player.y - 5, 10, 10);
            ctx.fillStyle = '#FFA500'; ctx.beginPath(); const flameHeight = Math.random() * 20 + 10; ctx.moveTo(player.x - player.width / 4, player.y + player.height / 3); ctx.lineTo(player.x + player.width / 4, player.y + player.height / 3); ctx.lineTo(player.x, player.y + player.height / 3 + flameHeight); ctx.closePath(); ctx.fill();
            if (gameState.hasShield) { ctx.strokeStyle = 'rgba(52, 152, 219, 0.8)'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(player.x, player.y, player.width, 0, Math.PI * 2); ctx.stroke(); }
        }
        function drawStars() { ctx.fillStyle = '#FFF'; for (const star of stars) { star.y += star.speed; if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; } ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill(); } }
        function drawPowerUps() { ctx.font = '28px Arial'; for (const p of powerUps) { ctx.save(); ctx.globalAlpha = p.life / GAME_SETTINGS.POWERUP_LIFESPAN; ctx.fillText(p.emoji, p.x - p.size, p.y - p.size); ctx.restore(); } }
        function drawBullets() { bullets.forEach(b => { ctx.fillStyle = b.color || '#FFD700'; if (b.type === 'laser') { ctx.save(); ctx.globalAlpha = 0.8; ctx.lineWidth = b.width; ctx.strokeStyle = b.color; ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x, 0); ctx.stroke(); ctx.restore(); } else { ctx.fillRect(b.x - b.width / 2, b.y, b.width, b.height); } }); }
        
        function updateAllUI() {
            scoreElement.textContent = `ÂàÜÊï∏: ${gameState.score}`;
            highScoreElement.textContent = `ÊúÄÈ´òÂàÜ: ${gameState.highScore}`;
            livesElement.textContent = `‚ù§Ô∏è ${gameState.lives}`;
            mainWeaponIcon.textContent = `Lv.${gameState.mainWeaponLevel}`;
            mainWeaponProgress.style.width = `${(gameState.mainWeaponXP / GAME_SETTINGS.MAIN_WEAPON_XP_TO_LEVEL) * 100}%`;
            
            subWeaponPanel.innerHTML = '';
            if (gameState.subWeapon.type) {
                const slot = document.createElement('div');
                slot.className = 'sub-weapon-slot';
                slot.innerHTML = `<span>${getPowerUpEmoji(gameState.subWeapon.type)}</span>
                                  <svg class="sub-weapon-timer-ring" viewBox="0 0 36 36">
                                    <path d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                                          fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="3" />
                                    <path d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                                          fill="none" stroke="#61dafb" stroke-width="3"
                                          stroke-dasharray="${(gameState.subWeapon.timer / GAME_SETTINGS.SUB_WEAPON_DURATION) * 100}, 100" />
                                  </svg>`;
                subWeaponPanel.appendChild(slot);
            }
        }
        
        function handlePlayerHit() {
            if (player.isInvincible) return;
            if (gameState.hasShield) { gameState.hasShield = false; player.isInvincible = true; player.invincibleTimer = 60; updateAllUI(); return; }
            gameState.lives--;
            player.isInvincible = true; player.invincibleTimer = GAME_SETTINGS.INVINCIBILITY_DURATION;
            gameState.subWeapon = { type: null, timer: 0 }; // Ê≠ª‰∫°ÂæåÂ§±ÂéªÂâØÊ≠¶Âô®
            updateAllUI();
            if (gameState.lives <= 0) doGameOver();
        }
        
        // --- Ê≠¶Âô® & ÈÅìÂÖ∑Á≥ªÁµ± ---
        function shootBullet() {
            const now = Date.now(); if (now - gameState.lastBulletTime < 180) return; gameState.lastBulletTime = now;
            const baseBullet = { y: player.y - player.height / 3, speed: 12 };
            // ‰∏ªÊ≠¶Âô®ÈñãÁÅ´
            if (gameState.mainWeaponLevel === 1) { bullets.push({ ...baseBullet, x: player.x, width: 5, height: 20 }); }
            else if (gameState.mainWeaponLevel === 2) { bullets.push({ ...baseBullet, x: player.x - 10, width: 5, height: 20 }); bullets.push({ ...baseBullet, x: player.x + 10, width: 5, height: 20 }); }
            else if (gameState.mainWeaponLevel >= 3) { bullets.push({ ...baseBullet, x: player.x, width: 6, height: 22 }); bullets.push({ ...baseBullet, x: player.x, width: 8, height: 8, angle: -0.3, speed: 10 }); bullets.push({ ...baseBullet, x: player.x, width: 8, height: 8, angle: 0.3, speed: 10 }); }
            // ÂâØÊ≠¶Âô®ÈñãÁÅ´
            const subWeaponType = gameState.subWeapon.type;
            if (subWeaponType === POWERUP_TYPES.LASER) { if (bullets.filter(b => b.type === 'laser').length === 0) { bullets.push({ type: 'laser', x: player.x, y: player.y, width: 10, color: '#2ecc71', life: 10 }); } }
            else if (subWeaponType === POWERUP_TYPES.SIDE_GUNS) { bullets.push({ ...baseBullet, x: player.x - player.width / 2, width: 6, height: 16, color: '#f39c12' }); bullets.push({ ...baseBullet, x: player.x + player.width / 2, width: 6, height: 16, color: '#f39c12' }); }
            else if (subWeaponType === POWERUP_TYPES.MISSILES) { if (now - (gameState.lastMissileTime || 0) > 400) { bullets.push({ ...baseBullet, x: player.x - 15, width: 8, height: 15, type: 'missile', turnSpeed: 0.05, target: findClosestEnemy(), color: '#9b59b6' }); bullets.push({ ...baseBullet, x: player.x + 15, width: 8, height: 15, type: 'missile', turnSpeed: 0.05, target: findClosestEnemy(true), color: '#9b59b6' }); gameState.lastMissileTime = now; } }
        }
        function getPowerUpEmoji(type) {
            switch(type) {
                case POWERUP_TYPES.MAIN_UPGRADE: return 'üîµ'; case POWERUP_TYPES.LASER: return 'üü¢'; case POWERUP_TYPES.SIDE_GUNS: return 'üü†';
                case POWERUP_TYPES.MISSILES: return 'üü£'; case POWERUP_TYPES.HEAL: return '‚ù§Ô∏è'; case POWERUP_TYPES.SHIELD: return 'üõ°Ô∏è'; default: return '';
            }
        }
        function spawnPowerUp(x, y) {
            if (Math.random() > GAME_SETTINGS.POWERUP_DROP_CHANCE) return;
            const availableTypes = [POWERUP_TYPES.MAIN_UPGRADE, POWERUP_TYPES.LASER, POWERUP_TYPES.SIDE_GUNS, POWERUP_TYPES.MISSILES, POWERUP_TYPES.HEAL, POWERUP_TYPES.SHIELD];
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            powerUps.push({ x, y, type, emoji: getPowerUpEmoji(type), speedY: 1.0, speedX: (Math.random() - 0.5) * 2, size: GAME_SETTINGS.POWERUP_SIZE, life: GAME_SETTINGS.POWERUP_LIFESPAN });
        }
        function applyPowerUp(powerUp) {
            switch(powerUp.type) {
                case POWERUP_TYPES.HEAL: if (gameState.lives < GAME_SETTINGS.LIVES_START_COUNT) gameState.lives++; break;
                case POWERUP_TYPES.SHIELD: gameState.hasShield = true; break;
                case POWERUP_TYPES.MAIN_UPGRADE:
                    if (gameState.mainWeaponLevel < 3) { gameState.mainWeaponXP++; if (gameState.mainWeaponXP >= GAME_SETTINGS.MAIN_WEAPON_XP_TO_LEVEL) { gameState.mainWeaponLevel++; gameState.mainWeaponXP = 0; showUnlockToast('‰∏ªÊ≠¶Âô®ÂçáÁ¥ö!'); } }
                    break;
                default: // Sub-weapons
                    if (gameState.subWeapon.type === powerUp.type) { gameState.subWeapon.timer += GAME_SETTINGS.SUB_WEAPON_DURATION; }
                    else { gameState.subWeapon = { type: powerUp.type, timer: GAME_SETTINGS.SUB_WEAPON_DURATION }; }
                    showUnlockToast(`Ë£ùÂÇô ${getPowerUpEmoji(powerUp.type)}`);
                    break;
            }
            updateAllUI();
        }
        function showUnlockToast(text) { unlockToast.textContent = text; unlockToast.style.opacity = '1'; setTimeout(() => { unlockToast.style.opacity = '0'; }, 1500); }
        function findClosestEnemy(second = false) { let firstClosest = null, secondClosest = null; let firstDist = Infinity, secondDist = Infinity; for(const e of enemies) { const dist = Math.hypot(e.x - player.x, e.y - player.y); if (dist < firstDist) { secondClosest = firstClosest; secondDist = firstDist; firstClosest = e; firstDist = dist; } else if (dist < secondDist) { secondClosest = e; secondDist = dist; } } return second ? secondClosest : firstClosest; }

        // --- Áâ©‰ª∂ÁÆ°ÁêÜ ---
        function spawnEnemy() { const now = Date.now(); if (now - gameState.lastEnemySpawnTime < gameState.enemySpawnInterval) return; const size = Math.random() * 25 + 20; const hp = Math.floor(1 + gameState.score / 1000); const type = Math.random() < (0.1 + gameState.score / 5000) ? 'tracker' : 'normal'; enemies.push({ x: Math.random() * (canvas.width - size * 2) + size, y: -size, size: size, hp, maxHp: hp, speed: Math.random() * 2 + (gameState.maxEnemySpeed - 2), color: `hsl(${Math.random() * 60 + 200}, 70%, 60%)`, type: type, }); gameState.lastEnemySpawnTime = now; }
        function createParticles(x, y, color) { for (let i = 0; i < 15; i++) { particles.push({ x, y, radius: Math.random() * 4 + 1, color: color, speedX: Math.random() * 8 - 4, speedY: Math.random() * 8 - 4, life: 60 }); } }
        function checkCollision(obj, target, radius) { const dx = obj.x - target.x; const dy = obj.y - target.y; return Math.sqrt(dx * dx + dy * dy) < radius; }
        function updateDifficulty() { gameState.enemySpawnInterval = Math.max(150, 1000 - gameState.score / 3); gameState.maxEnemySpeed = Math.min(7, 2.0 + gameState.score / 400); }
        function updateEntities() {
            if(player.isInvincible) { player.invincibleTimer--; if(player.invincibleTimer <= 0) player.isInvincible = false; }
            if(gameState.subWeapon.timer > 0) { gameState.subWeapon.timer--; if(gameState.subWeapon.timer <= 0) gameState.subWeapon.type = null; }
            for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (b.type === 'missile') { if (b.target && enemies.includes(b.target)) { const angle = Math.atan2(b.target.y - b.y, b.target.x - b.x); b.x += Math.cos(angle) * b.speed; b.y += Math.sin(angle) * b.speed; } else { b.y -= b.speed * 0.8; } } else if (b.type === 'laser') { b.life--; if (b.life <= 0) bullets.splice(i, 1); b.x = player.x; b.y = player.y; } else { b.y -= b.speed; if(b.angle) b.x += b.angle * b.speed; } if (b.y < -20 || b.x < -20 || b.x > canvas.width + 20) bullets.splice(i, 1); }
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i]; e.y += e.speed;
                if (e.type === 'tracker') { const angle = Math.atan2(player.y - e.y, player.x - e.x); e.x += Math.cos(angle) * 0.5; }
                if (checkCollision({x: player.x, y: player.y}, e, (player.width/2 + e.size)/2)) { handlePlayerHit(); enemies.splice(i, 1); continue; }
                for (let j = bullets.length - 1; j >= 0; j--) { const b = bullets[j]; if (b.type === 'laser') { if(Math.abs(e.x - b.x) < e.size) e.hp -= 0.2; } else if (checkCollision(b, e, e.size)) { e.hp--; bullets.splice(j, 1); } if(e.hp <= 0) { createParticles(e.x, e.y, '#FFD700'); gameState.score += Math.floor(e.maxHp * 10); spawnPowerUp(e.x, e.y); enemies.splice(i, 1); break; } }
                if (e.y > canvas.height + e.size) enemies.splice(i, 1);
            }
            for (let i = powerUps.length - 1; i >= 0; i--) { const p = powerUps[i]; p.y += p.speedY; p.x += p.speedX; p.life--; if (p.x < p.size || p.x > canvas.width - p.size) p.speedX *= -1; if (p.y < p.size || p.y > canvas.height - p.size) p.speedY *= -1; if (checkCollision(player, p, (player.width / 2 + p.size))) { applyPowerUp(p); powerUps.splice(i, 1); continue; } if (p.life <= 0) powerUps.splice(i, 1); }
            for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.speedX; p.y += p.speedY; p.life--; ctx.globalAlpha = p.life / 60; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); if (p.life <= 0) particles.splice(i, 1); }
            ctx.globalAlpha = 1;
        }
        
        // --- ‰∏ªÂæ™Áí∞ ---
        function gameLoop() {
            if (gameState.gameOver) return;
            if (gameState.controlScheme === 'touch' && gameState.touchDirection) {
                if (gameState.touchDirection === 'left') player.x -= GAME_SETTINGS.PLAYER_MAX_SPEED;
                if (gameState.touchDirection === 'right') player.x += GAME_SETTINGS.PLAYER_MAX_SPEED;
            }
            player.x = Math.max(player.width / 2, Math.min(canvas.width - player.width / 2, player.x));
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars(); drawPlayer(); drawPowerUps(); drawBullets();
            for (const enemy of enemies) { const healthRatio = enemy.hp / enemy.maxHp; ctx.fillStyle = `hsl(0, ${100 - healthRatio * 100}%, 60%)`; ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2); ctx.fill(); }
            
            shootBullet(); updateEntities(); spawnEnemy(); updateDifficulty(); updateAllUI();
            
            gameState.animationId = requestAnimationFrame(gameLoop);
        }

        // --- ‰∫ã‰ª∂Áõ£ËÅΩ ---
        gyroBtn.addEventListener('click', () => selectControlScheme('gyro')); touchBtn.addEventListener('click', () => selectControlScheme('touch'));
        startBtn.addEventListener('click', startGame); restartBtn.addEventListener('click', () => window.location.reload());
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gameState.started || gameState.gameOver || gameState.controlScheme !== 'touch') return; const touchX = e.touches[0].clientX; gameState.touchDirection = touchX < canvas.width / 2 ? 'left' : 'right'; });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); if (!gameState.started || gameState.gameOver || gameState.controlScheme !== 'touch') return; const touchX = e.touches[0].clientX; gameState.touchDirection = touchX < canvas.width / 2 ? 'left' : 'right'; });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); if (!gameState.started || gameState.gameOver || gameState.controlScheme !== 'touch') return; gameState.touchDirection = null; });
        
        // --- ÂïüÂãï ---
        resizeCanvas();

    </script>
</body>
</html>
